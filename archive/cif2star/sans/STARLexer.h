/*
 * $Id: STARLexer.h 78 2006-08-18 21:59:40Z dmaziuk $
 *
 * This software is copyright (c) 2006 Board of Regents, University of Wisconsin.
 * All Rights Reserved.
 *
 */
 
#ifndef _STARLEXER_H_
#define _STARLEXER_H_

#include <string>
#include <cstdio>
/**
 * \class STARLexer
 * \brief STAR scanner (lexer) class.
 *
 * This is a wrapper class for scanner generated by GNU Flex: authors
 * of Flex strongly recommended that I do not use a Flex-generated C++
 * scanner and roll my own C++ wrapper for C scanner instead. As a result,
 * this scanner uses C-style <i>FILE *</i> input stream rather than C++
 * istream.
 * <p>
 * Scanner's main method is <i>int lex()</i> instead of more familiar 
 * <i>yylex()</i>.
 * <p>
 * STARLexer's methods are implemented in <i>star.l</i> file.
 * <p>
 * <strong>Performance notes:</strong><br>
 *  - Quoted values (either single- or double-quote) are parsed one character at a time
 *  - Semicolon-delimited values are parsed one line at a time<br>
 * (this is done to defeat greedy matching). In both cases parsed character/line is
 * appended to a buffer. As a result, very long quoted/delimited values will generate
 * a lot of <code>std::string::append()</code> calls and slow down the scanner.
 */
class STARLexer {
  public:
    static const int GLOBALSTART = 1;    ///< Start of global block token returned by the scanner
    static const int GLOBALEND = 2;      ///< End of global block token returned by the scanner
    static const int DATASTART = 3;      ///< Start of data block token returned by the scanner
    static const int DATAEND = 4;        ///< End of data block token returned by the scanner
    static const int SAVESTART = 5;      ///< Start of saveframe token returned by the scanner
    static const int SAVEEND = 6;        ///< End of saveframe token returned by the scanner
    static const int LOOPSTART = 7;      ///< Start of loop token returned by the scanner
    static const int STOP = 8;           ///< End of loop token returned by the scanner
    static const int TAGNAME = 9;        ///< Tag token returned by the scanner
    static const int DVNSINGLE = 10;     ///< Value in single quotes token returned by the scanner
    static const int DVNDOUBLE = 11;     ///< Value in double quotes token returned by the scanner
    static const int DVNSEMICOLON = 12;  ///< Semicolon-delimited value token returned by the scanner
    static const int DVNFRAMECODE = 13;  ///< Framecode value token returned by the scanner
    static const int DVNNON = 14;        ///< Bareword value token returned by the scanner
    static const int COMMENT = 15;       ///< Comment token returned by the scanner
    static const int FILEEND = 16;       ///< EOF token returned by the scanner
    static const int ERROR = -1;         ///< Error token returned by the scanner
    static const int WARNING = -3;       ///< Warning token returned by the scanner
    /**
     * STAR value types.
     */
    enum Types { 
        SINGLE = DVNSINGLE,       ///< enclosed in single quotes
        DOUBLE = DVNDOUBLE,       ///< enclosed in single quotes
	SEMICOLON = DVNSEMICOLON, ///< semicolon-delimited
	FRAMECODE = DVNFRAMECODE, ///< framecode value
	NON = DVNNON              ///< bareword value
    }; // valtypes; 
    /**
     * \brief scanner's main method.
     *
     * \return one of integer "token" constants.
     */
    int lex();
    /**
     * \brief default constructor.
     *
     * You must setIn( FILE *) if you use this constructor.
     */
    STARLexer() {};
    /**
     * \brief Constructor on input stream.
     *
     * \param in C-style input stream.
     */
    STARLexer( FILE *in );
    /**
     * \brief Changes scanner's input stream.
     *
     * \param in C-style input stream.
     */
    void setIn( FILE *in );
    /**
     * \brief Returns token text.
     *
     * For tag names and bareword values this is equivalent to <i>yytext()</i>.
     * For other tokens it isn't: e.g. saveframe names are returned without the
     * leading "save_", etc.
     * \return token text
     */
    std::string &getText();
    /**
     * \brief Returns token's line number in input file.
     *
     * \return line number
     */
    int getLine();
    /**
     * \brief Returns -1.
     *
     * Column counting is currently not supported.
     * \return -1
     */
    int getColumn() { return -1; };
    /**
     * \brief Pushes <i>numchars</i> characters back into input buffer.
     *
     * Calls <i>yyless( numchars )</i>
     * <p>
     * Note that delimited values are parsed character-by-character, so
     * there only one character available for pushback after reading a
     * value enclosed in semicolons, single, or double quotes.
     * \param numchars number of characters to push back
     */
    void pushBack( int numchars );

  private:
    std::string buf;       ///< storage for multi-line tokens
    std::string blockname; ///< name of the data block
    std::string savename;  ///< name of current saveframe
};
#endif // STARLEXER_H
